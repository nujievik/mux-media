from pathlib import Path
import re

from wcwidth import wcswidth

PROJECT_DIR = Path(__file__).resolve().parent.parent
GEN_BY = Path(__file__).relative_to(PROJECT_DIR)

SOURCE = PROJECT_DIR / "resources" / "iso639_language_list.cpp"
OUT_ENUM = PROJECT_DIR / "src" / "types" / "lang_code.rs"
OUT_MAP_FROM_STR = PROJECT_DIR / "src" / "types" / "lang_code" / "map_from_str.rs"
OUT_LIST_LANGS = PROJECT_DIR / "src" / "types" / "lang_code" / "list_langs.rs"

def read_language_data(source_path):
    with open(source_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    full_names = []
    codes = []
    max_name_len = 0

    for line in lines:
        if "Reserved for local use" in line:
            continue

        match = re.search(r'{\s*"([^"]*)",\s*"([^"]*)",\s*"([^"]*)",\s*"([^"]*)"', line)
        if match:
            name = match.group(1).strip()
            _codes = [match.group(i).strip() for i in range(2, 5) if match.group(i).strip()]
            if not _codes:
                continue

            full_names.append(name)
            codes.append(_codes)
            max_name_len = max(max_name_len, len(name))

    return full_names, codes, max_name_len


def to_pascal(code: str) -> str:
    return ''.join(word.capitalize() for word in code.split('_'))


def generate_enum(codes, output_path):
    enum_variants = [f"    {to_pascal(_codes[0])}," for _codes in codes]
    rust_enum = f"""// Auto-generated by {GEN_BY}

mod impls;
mod list_langs;
mod map_from_str;
mod set_multiple_priority;

use strum_macros::AsRefStr;

#[derive(Copy, Clone, Debug, Eq, Hash, PartialEq, AsRefStr)]
#[strum(serialize_all = "kebab-case")]
"""
    rust_enum += (
        "pub enum LangCode {\n" +
        '\n'.join(enum_variants) +
        "\n}\n"
    )

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(rust_enum)
    print("✅ Rust enum generated ->", output_path)


def generate_map_from_str(codes, output_path):
    map_entries = []
    for _codes in codes:
        enum = to_pascal(_codes[0])
        for code in _codes:
            map_entries.append(f'    "{code}" => LangCode::{enum},')

    rust_map = f"""// Auto-generated by {GEN_BY}

use super::LangCode;
use phf::phf_map;

"""
    rust_map += (
        "pub(in crate::types::lang_code) static MAP_FROM_STR: phf::Map<&'static str, LangCode> = phf_map! {\n" +
        '\n'.join(map_entries) +
        "\n};\n"
    )

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(rust_map)
    print("✅ PHF map generated ->", output_path)


def generate_list_langs(names, codes, max_name_len, output_path):
    NAME_COLUMN = max_name_len + 1
    CODE_COLUMN = 16

    header = "English language name".ljust(NAME_COLUMN)
    for title in ["ISO 639-3 code", "ISO 639-2 code", "ISO 639-1 code"]:
        header += "|" + " " + title.ljust(CODE_COLUMN - 1)
    header += "\n"

    separator = "-" * NAME_COLUMN + "+" + "+".join(["-" * CODE_COLUMN] * 3) + "\n"

    def visual_width(s): return wcswidth(s)

    body = ""
    for name, code_list in zip(names, codes):
        padding = NAME_COLUMN - visual_width(name)
        line = name + ' ' * padding
        for code in code_list:
            line += "|" + " " + code.ljust(15)
        while len(code_list) < 3:
            line += "|" + " " + " " * 15
            code_list.append("")
        line += "\n"
        body += line

    rust_list_langs = (
        f"// Auto-generated by {GEN_BY}\n\n"

        'pub(in crate::types::lang_code) static LIST_LANGS: &str = r#"\n'
        f'{header}{separator}{body}"#;\n'
    )

    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(rust_list_langs)
    print("✅ Help language list generated ->", output_path)


def main():
    names, codes, max_name_len = read_language_data(SOURCE)
    generate_enum(codes, OUT_ENUM)
    generate_map_from_str(codes, OUT_MAP_FROM_STR)
    generate_list_langs(names, codes, max_name_len, OUT_LIST_LANGS)


if __name__ == "__main__":
    main()
