from pathlib import Path
import itertools

PROJECT_DIR = Path(__file__).resolve().parent.parent
GEN_BY = "// Auto-generated by " + str(Path(__file__).relative_to(PROJECT_DIR))
MODULE = PROJECT_DIR / "src" / "types" / "extensions"
MODULE_ROOT = MODULE.with_suffix(".rs")

OUT_PATHS = {
    "avi": MODULE / "avi.rs",
    "fonts": MODULE / "fonts.rs",
    "matroska": MODULE / "matroska.rs",
    "media": MODULE / "media.rs",
    "mp4": MODULE / "mp4.rs",
    "otf": MODULE / "otf.rs",
    "subs": MODULE / "subs.rs",
    "webm": MODULE / "webm.rs",
}

EXTS = {
    "avi": { "avi" },

    "mp4": { "mp4" },

    "webm": { "webm" },

    "otf": ["otf"],

    # Common for video and audio
    "container": {
        "3gp",
        "av1",
        "avi",
        "f4v",
        "flv",
        "m2ts",
        "mkv",
        "mp4",
        "mpg",
        "mov",
        "mpeg",
        "ogg",
        "ogm",
        "ogv",
        "ts",
        "webm",
        "wmv"
    },

    "video": {
        "264",
        "265",
        "avc",
        "h264",
        "h265",
        "hevc",
        "ivf",
        "m2v",
        "mpv",
        "obu",
        "vc1",
        "x264",
        "x265",
        "m4v"
    },

    "audio": {
        "aac",
        "ac3",
        "caf",
        "dts",
        "dtshd",
        "eac3",
        "ec3",
        "flac",
        "m4a",
        "mka",
        "mlp",
        "mp2",
        "mp3",
        "mpa",
        "opus",
        "ra",
        "thd",
        "truehd",
        "tta",
        "wav",
        "weba",
        "webma",
        "wma"
    },

    "subs": [
        "ass",
        "mks",
        "srt",
        "ssa",
        "sub",
        "sup"
    ],

    "fonts": [
        "otf",
        "ttf"
    ],

    "matroska": [
        "mka",
        "mks",
        "mkv",
        # WebM global metadata is based on the Matroska tag specs.
        # Also mkvinfo is support .webm
        "webm"
    ],

    "rtm_subs": [
        "ass",
        "srt"
    ],
}

EXTS["video"] = sorted(EXTS["video"].union(EXTS["container"]))
EXTS["audio"] = sorted(EXTS["audio"].union(EXTS["container"]))
EXTS["media"] = sorted(set(EXTS["video"]) | set(EXTS["audio"]) | set(EXTS["subs"]))


def case_permutations(ext: str) -> set[str]:
    """Generate all case permutations of a string."""
    return {"".join(p) for p in itertools.product(*[(c.lower(), c.upper()) for c in ext])}


def generate_phf_set(exts: list[str], set_name: str) -> str:
    all_exts = []
    for ext in exts:
        perms = sorted(case_permutations(ext))
        all_exts.extend(perms)
    lines = '\n    '.join(f'b"{e}",' for e in all_exts)
    return f"""{GEN_BY}

pub static {set_name.upper()}: phf::Set<&[u8]> = phf::phf_set! {{
    {lines}
}};
"""


def generate_module_root(names: list[str]) -> str:
    mods: str = "\n".join(f"mod {name};" for name in names)

    struct_fields = "\n".join(f"    pub {name}: &'static Set<&'static [u8]>," for name in names)
    struct: str = "pub struct Extensions {\n" + struct_fields + "\n}"

    static_fields = "\n".join(f"    {name}: &{name}::{name.upper()}," for name in names)
    static: str = "pub static EXTENSIONS: Extensions = Extensions {\n" + static_fields + "\n};"

    return f"""{GEN_BY}

{mods}

use phf::Set;

/// A sets of file type extensions, stored as byte slices (`&[u8]`).
{struct}

/// The static collection of file type extensions.
{static}
"""


def main():
    names = list()

    for name, path in sorted(OUT_PATHS.items()):
        content = generate_phf_set(EXTS[name], name)
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(content, encoding="utf-8")
        print(f"✅ Generated -> {path}")
        names.append(name)

    content = generate_module_root(names)
    MODULE_ROOT.write_text(content, encoding="utf-8")
    print(f"✅ Generated -> {MODULE_ROOT}")


if __name__ == "__main__":
    main()
